# Лабораторная работа №4

## Задание №1

Реализовать клиент-серверное приложение. Сервер запускается и ожидает подключения клиентов, клиент, подключившись к серверу, отправляет ему порядковый номер и интервал, после чего сервер возвращает набор чисел, которые делятся одновременно на 11, 13 и 17. Предусмотреть вывод консольных сообщений на стороне сервера.

Одновременно в программу можно передать несколько интервалов, каждый интервал обрабатывается в отдельном потоке на сервере. Пользователь вводит число в консоль, после чего программа разбивает его на интервалы по 1 000 000 и отправляет на сервер. Например:

```
Поступило число 3 345 212

Программа создаст следующие интервалы:

1 - 1 000 000

1 000 001 - 2 000 000

2 000 001 - 3 000 000

3 000 001 - 3 345 212
```

Сервер ожидает подключения клиентов. После подключения всех клиентов, каждому из них выдаётся порядковый номер и интервал. В консоль выводится, какой интервал каждому из них был выдан. После этого сервер находит необходимые числа и выводит их в консоль.

### Пример клиент-серверного приложения на Python (сканер портов)

#### Сервер

```python
from socket import AF_INET, SOCK_DGRAM, socket, timeout

# Время ожидания сообщения от клиента
time = 7200
# Данные сервера
ip = 'localhost'
port = 540
# Создание сокета
server = socket(AF_INET, SOCK_DGRAM)
server.bind((ip, port))

# Обработчик
while True:
  server.settimeout(time)
  # Попытка получить и отправить сообщение
  try:
    data = server.recvfrom(1024)
    print(data[0])
    server.sendto(b'OK', data[1])
  except timeout:
    break
server.close()
```

#### Клиент

```python
from socket import socket, AF_INET, SOCK_RAW, IPPROTO_ICMP, setdefaulttimeout, timeout

# Сканер UDP портов
def scanner_UDP(ip, port):
  setdefaulttimeout(1.0)
  # Создание сокета
  sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)
  sock.settimeout(0.5)
  # Отправка сообщения
  sock.sendto(b'Test message', (ip, port))
  # Попытка получения ответа
  try:
    sock.recvfrom(1024)
    print(f'Port: {port} is open')
    sock.close()
  # Если ошибка timeout, то порт считается открытым
  # except timeout:
  #  print(f'Port: {port} is open')
  except:
    pass
```

## Задание №2

Переписать приложение из первого задания под асинхрон. Сравнить его работу с многопоточным приложением.
